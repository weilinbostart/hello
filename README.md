## 第一章 JVM和java体系结构

### 1.前言

- 学jvm的目的：项目管理，调优，面试，了解GC机制，JIT
- java vs c++:C++是需要手动管理内存的，这样作有好有坏，好处是如果对内存管理比较熟悉，可以提高程序的性能，坏处是操作繁杂难度高。虽然java引入了GC机制，但该机制也不是万能的，所以还是有必要了解jvm的内存结构，工作机制。

### 2.java和jvm简介

- java跨平台语言：write once , run anywhere，java语言编译出的字节码文件可以在不同版本的jvm上运行，实现了一次编译，到处运行。
- jvm跨语言平台：java虚拟机不但可以运行java程序，也可以运行其他语言，只需要其他语言编译出的字节码文件也符合jvm的规范就行。换句话说jvm只关心字节码文件，不关心是什么语言编译出来的。
- 字节码：字节码文件不单指java语言编译出来的文件，其他语言通过不同编译器也可以编译出相同的字节码文件，字节码文件也可以在不同的jvm上运行。
- 多语言混合编程：由于上述特点，java虚拟机正在向多语言虚拟机方向发展，针对不同特点的问题使用针对性的语言，每个语言可以使用各自的API，最后只需要生成的字节码文件符合jvm规范即可。

### 3.java发展的重大事件

- 95java首次亮相，96发布jdk1.0，98分为javaEE,javaSE,javaME分别对应企业开发，桌面应用开发，移动开发。04jdk5.0

### 4.虚拟机和java虚拟机

- 虚拟机可分为：系统虚拟机和程序虚拟机，系统虚拟机是指完全对物理计算机的仿真，提供了完整的操作系统的软件平台。程序虚拟机是专门位运行单个程序设计的 。
- java虚拟机属于程序虚拟机，java虚拟机是java的核心技术，其显著特点有：跨平台性，优秀的GC，可靠的及时编译器。作用是二进制字节码的运行环境。所处位置在操作系统之上
- ![image-20210604172849625](C:\Users\WAW\AppData\Roaming\Typora\typora-user-images\image-20210604172849625.png)

### 5.jvm整体结构

- ![image-20210604173013740](C:\Users\WAW\AppData\Roaming\Typora\typora-user-images\image-20210604173013740.png)

### 6.java代码的执行流程

- ![image-20210604173132082](C:\Users\WAW\AppData\Roaming\Typora\typora-user-images\image-20210604173132082.png)

### 7.jvm的指令集架构模型

- 指令集架构分为两种：基于栈的指令架构，基于寄存器的指令架构，java虚拟机是一种基于栈的指令架构。两者各有特点。
  - 基于栈的指令架构的特点是
    - 1.设计简单，适用于资源受限的系统。
    - 2.避开的寄存器的分配难题：使用零地址指令方式分配（由于使用的是栈，所以只需要维护栈顶元素即可，不需要多余的存储空间去维护指令的地址）
    - 3.指令集更小但指令多。
    - 4.不需要硬件支持，可移植性好，可实现跨平台，因为基于栈的指令架构是面向内存的，所以跟硬件不是强相关。
  - 基于寄存器的指令架构特点则是：
    - 1.跟硬件强相关，可移植性差，但可量身打造所以性能更高效
    - 2.需要维护指令地址
    - 3.指令集更大

### 8.jvm的生命周期

- 虚拟机的启动：通过类加载器创建一个初始类来完成（包括Object但不限于Object）
- 虚拟机的执行：程序执行时虚拟机执行，通俗易懂
- 虚拟机的停止：1.程序正常结束。2.程序发生异常而终止。3.系统发生异常而终止，4.主动调用System的exit方法或Runtime的halt方法

### 9.jvm的发展历程

- Sun Classic VM:第一款商用的JVM，内部只提供了解释器，现在的hotspot内置了此虚拟机
- Exact VM:继第一代VM后出现的昙花一现的VM，但以及具有高性能VM的雏形，因为其有热点探测（可以把高频率执行的指令预编译出来）
- Hot Sport:占有绝对的市场优势，应用面比较广，从服务器，桌面到移动端，嵌入式都有应用，它的名字HotSpot就指的是他的热点代码探测技术：通过计数器找到最具有编译价值的代码，触发即时编译或栈上替换；通过编译器和解释器的系统工作，在最优化的程序响应时间和最佳执行性能中取得平衡。
- JRockit:专注于服务器应用，内部不包含解释器的实现，全部代码都靠及时编译器编译后运行，牺牲了程序响应时间实现了性能上的最优
- J9：号称是最快，跟Hot Sport的市场定位差不多，是三大商用服务器之际



## 第二章 类加载子系统

### 1.内存结构概述

- ![image-20210605210546777](C:\Users\WAW\AppData\Roaming\Typora\typora-user-images\image-20210605210546777.png)
  - jvm主要分为三个部分：类加载器子系统，运行时数据区，执行引擎
    - 类加载器子系统作用主要是将字节码文件加载到内存中，类 加载器子系统又可分成三个阶段：加载阶段，链接阶段，初始化阶段。加载阶段是把字节码文件加载到内存中，类加载器有引导类加载器（主要加载核心API），扩展类加载器，系统类加载器，自定义加载器
    - 程序计数器和栈空间是线程分用的，堆空间是线程公用的

### 2.类加载器和类的加载过程

- 类加载器子系统的作用：
  - 类加载器子系统作用主要是将字节码文件加载到内存中，class文件的开头有特定的文件标识（咖啡宝贝）
  - 类加载器子系统只负责加载，至于是否可以运行要看执行引擎
  - 加载的类的信息（class file 也称为DNA元数据模板）存放在内存中的方法区中，方法区中还有常量池
- 类加载器角色
  - ![image-20210605211806070](C:\Users\WAW\AppData\Roaming\Typora\typora-user-images\image-20210605211806070.png)

- 类加载过程
  - ![image-20210605212115364](C:\Users\WAW\AppData\Roaming\Typora\typora-user-images\image-20210605212115364.png)
  - ![image-20210605212209761](C:\Users\WAW\AppData\Roaming\Typora\typora-user-images\image-20210605212209761.png)
  - 加载：通过全类名获取这个类的字节流，将字节流转化为方法区中的运行时数据结构，在内存中生成代表这个类的java.lang. Class对象，作为这个类的各种数据的访问入口。
    - 加载字节码文件的方式：从本地，从网络，从zip压缩包（jar,war基础），运行时计算生成（动态代理居多），有其他文件生成（jsp），从专有数据库提取（少见），从加密文件中获取（需要自定义的加载器解密	）
  - 链接：
    - 验证：目的是确保Class文件的字节流中包含信息符合当前加载器的要求
    - 准备：为类变量分配内存并设初始值（零值），准备阶段显示初始化，但这里的类变量不包括被final关键字修饰的类变量，这种编译时就初始化了。这里也不包括实例变量，类变量回分配到方法区中，而实例变量会随对象一起分配到堆中
    - 解析：将符号引用转换为直接引用
  - 初始化
    - 初始化阶段就是执行类构造器方法<clinit>()的过程，但这个方法不需定义自动调用，他会执行所有类变量的赋值动作，包括构造器中的和静态代码块重点，具体执行顺序看先后
    - <clinit>()不同于构造器，<init>()对应构造器，字节码文件可能没有<clinit>但是一定有<init>
    - 若该类有父类，则先执行父类的<clinit>
    - 每个类只被加载一次，是同步加锁的，意思就是一个线程若在通过类生成对象时发生了阻塞，那么其他线程就没有办法通过此类生成对象。
- 类加载器分类
  - 类加载器有引导类加载器（主要加载核心API），扩展类加载器，系统类加载器，自定义加载器。这四者不是继承关系，是包含关系
  - 引导类加载器：
    - 这个加载器是使用c/c++写的，嵌套在JVM内部
    - 用来加载核心库
    - 不继承于java.lang.ClassLoader，没有父加载器
    - 只加载java,javax,sun开头的类
  - 扩展类加载器
    - 派生于ClassLoader
  - 系统类加载器
    - 是程序默认的类加载器，一般来说应用类都是由该加载器加载的
    - 派生于ClassLoader
  - 用户自定义类加载器
    - 平常使用中用上面三个加载器就可以，但有些特殊情况需要自定义类加载器：隔离加载类，为了防止类名重复可以使用不同的类加载器对类进行加载2.修改类加载的方式3.扩展加载源4.防止源码泄露（有些文件为了防止被反编译，需要对其进行加密，这种情况需要自定义类的加载器对字节码文件进行解密）
  - 用户自定义加载器实现步骤
    - 可以通过继承抽象类java.lang.ClassLoader类的方式实现
    - 并建议把类加载逻辑写在findClass（）方法中
    - 如果没有太过复杂的逻辑，可以直接继承URLClassLoader，可避免编写findClass()和获取字节码流的方式，使代码整洁
- 关于ClassLoader
  - ClassLoader是一个抽象类，所有的类加载器都继承自ClassLoader不包括引用类加载器
  - 获取ClassLoader的途径
    - ![image-20210605232454314](C:\Users\WAW\AppData\Roaming\Typora\typora-user-images\image-20210605232454314.png)

### 3.双亲委派机制

- java虚拟机对class文件采用的是按需加载，意思是只有需要此类时才会把她加载到内存中，而加载一个类时采用的是双亲委派机制，即会把请求交给父类处理
- 工作原理：
  - ![image-20210605233723925](C:\Users\WAW\AppData\Roaming\Typora\typora-user-images\image-20210605233723925.png)
- 优势
  - 避免类的重复加载
  - 保护程序安全，防止核心API 被随意篡改，比如若在程序中自定一个包java.lang并在此包下定义一个String类，若不采用这种机制的话系统类加载器会直接把此类加载进来，这就会引起很大的问题。有了这种机制，引导类加载器就会率先把String类加载
- 沙箱安全机制
  - 沙箱安全机制

### 5.其他

- jvm中表示两个类是同一个类的条件是：1、两个类的全类名一样2、使用同一个类加载器加载
- jvm必须要知道一个类型是由引用类加载器还是由用户类加载器加载的
- 类的主动使用和被动使用



## 第三章 运行时数据区概述及线程

### 1.概述

- ![image-20210606092642749](C:\Users\WAW\AppData\Roaming\Typora\typora-user-images\image-20210606092642749.png)
- 内存是非常重要的资源是承载操作系统和应用程序的实时运行，不同的JVM对内存的划分方式和管理机制存在着部分差异
- ![image-20210606092952324](C:\Users\WAW\AppData\Roaming\Typora\typora-user-images\image-20210606092952324.png)
  - 此图是阿里对HotSport JVM运行时区的描绘，其中程序计数器（PC）、虚拟机栈（VMS）、本地方法栈（NMS）为线程独享，堆，堆外内存（永久代或元空间、代码缓存）为线程共享
  - 每个JVM只有一个Runtime实例，即为运行时环境

### 2.线程

- 一个进程可以由多个线程，线程是程序里的运行单元，JVM允许多个线程并行，当多个线程要共享资源时要考虑到同步问题，在HotspotJVM中每个线程都与操作系统的本地线程有直接映射。
- JVM系统线程：



## 第四章  程序计数器

![image-20210606100257183](C:\Users\WAW\AppData\Roaming\Typora\typora-user-images\image-20210606100257183.png)

- 程序计数器简介：程序计数器是jvm运行时区中唯一的寄存器，用来存放下一条指令的地址，每个线程独享一个程序计数器。他是唯一一个在jvm规范中没有规定任何OOM（out of memory erro）情况的区域
  - PC没有GC也没有OOM , 栈没有GC但有OOM，堆和方法区有GC和OOM
- 两个常见问题
  - 为什么使用PC寄存器记录当前进程的执行地址：因为CPU需要不停的切换各个线程，需要PC记录每个线程运行到了哪条指令
  - 为什么pc会设定为每个线程私有：因为cpu要来回切换线程，所以需要记录每个线程正在执行的当前字节码指令地址，最好的办法就是为每一个线程分配一个pc寄存器
- cpu时间片
  - cpu分配给每个线程的时间段，并行：多个任务同时执行，并发：多个任务看似是同时进行，但其实单个任务单独进行，只是cpu在不同任务间来回作切换

## 第五章 虚拟机栈

### 1.虚拟机栈概述

- 虚拟机栈出现的背景：由于跨平台的设计，所以java的指令不能是基于寄存器设计而是选择基于栈设计，这种设计方式的特点是可以跨平台，编译器容易实现，指令集小，但是相对于基于寄存器的设计速度会慢些，执行同样的功能需要更多的指令
- 内存中的堆和栈：栈解决的是程序的运行问题，堆解决的是数据的存储问题
- 虚拟机栈的基本内容：
  - 每个线程创建的时候都会创建一个虚拟机栈，其内部保存一个个栈帧，生命周期跟线程一致。
  - 作用是主管java程序的运行，它保存方法的局部变量，部分结果，并参与方法的调用和返回。
  - 虚拟机栈的速度仅次于PC
  - 每个方法的执行都伴随着入栈出栈，执行结束后出栈
  - 虚拟机栈没有GC
- 虚拟机栈可能会出现的异常：StackOverFlowError和OutOfMemeryError
  - 若采用固定大小的java虚拟机栈，当超过设定的最大值时会报StackOverFlowError
  - 若采用动态扩展的虚拟机栈，当扩展申请没有被满足的时候会报OutOfMemeryError
  - 可以使用参数-Xss设置栈空间大小

### 2.栈的存储单位

- 栈运行原理
  - 每个线程都有自己的栈，栈帧是栈中数据的基本单位，在这个线程上正在执行的每个方法都有各自对应的栈帧，栈帧是一个内存区块，里面存放着方法执行过程中的各种数据信息
  - 一个时间点上只会有一个活动的栈帧，这个栈帧称为当前栈帧，对应的方法为当前方法，对应的类为当前类，执行引擎只针对当前栈帧进行操作，若该方法调用的其他方法，会生成对应的新的栈帧放在顶端，成为当前栈帧，如下图：
    - ![image-20210606215040302](C:\Users\WAW\AppData\Roaming\Typora\typora-user-images\image-20210606215040302.png)
  - 不同线程中包含的栈帧是不允许存在相互引用的
  - java方法有两种返回函数的方式，一种是正常的函数返回，一种是抛出异常，不管是哪种方式，都会导致栈帧弹出
- 栈帧的内部结构：每个栈帧中有局部变量表（Local variables），操作数栈（Operand Stack），动态链接，方法返回地址，一些附加信息
  - ![image-20210607105128514](C:\Users\WAW\AppData\Roaming\Typora\typora-user-images\image-20210607105128514.png)

### 3.局部变量表

- 局部变量表也被称为局部变量数组，因为它本质上是一个数字数组，主要用于存储方法参数和定义在其内部的局部变量，这些数据类型包括基本数据类型，对象引用和returnAddress类型
- 局部变量表是线程私有的，所以不存在数据安全问题
- 局部变量表所需的容量大小在编译期确定下来
- 方法嵌套调用的次数由栈的大小决定，而一个栈帧的大小主要由局部变量表决定，局部变量表越大，栈帧越膨胀
- 局部变量表中的变量只在当前方法调用中有效
- 局部变量表中的基本单位为变量槽Slot，一个变量槽大小是32位，所存放的数据中除了double和long类型外占两个槽外，其余类型都只占一个槽
- ![image-20210607101101103](C:\Users\WAW\AppData\Roaming\Typora\typora-user-images\image-20210607101101103.png)
  - 每个slot都有一个访问索引通过索引访问局部变量表中的数据
  - 当一个方法被调用时，它的方法参数和其内部定义的局部变量会按顺序依次复制到局部变量表中，若访问的数据占两个槽，则访问第一个槽的索引即可，若当前栈帧是由构造方法或实例方法创建的，则index0处应放this变量
  - slot可以复用，当一个局部变量超出了其作用域，则空出的slot可以被其他局部变量复用
- 静态变量和局部变量的对比：静态变量有两次赋值机会，一次是在准备阶段对类变量赋零值，一次是在初始化阶段赋真值，但局部变量没有这两次机会，所以它在定义时就应该赋初始值，否则编译不通过
- 在栈帧中与性能调优最密切相关的时栈帧中的局部变量表，因为被局部变量表中的变量直接或间接指向的对象都不会被回收，属于垃圾回收根节点

### 4.操作数栈

- 操作数栈也称为表达式栈，在方法执行过程中，根据字节码指令存入数据和读取数据
- ![image-20210607102741671](C:\Users\WAW\AppData\Roaming\Typora\typora-user-images\image-20210607102741671.png)
- 操作数栈主要用于保存计算过程的中间结果，同时作为计算过程中临时的存储空间，一开始操作数栈是空的，随着方法的调用才被创建，且其长度在编译时就被确定 
- 32位占一个栈，64占两个，其访问并像局部变量表那样使用索引，这里只是用出栈入栈
- 若调用方法有返回值，则其返回值也会被压入操作数栈
- 我们通常说的执行引擎基于栈的，这里的栈指的就是操作数栈

### 5.代码追踪

- ![image-20210607103843249](C:\Users\WAW\AppData\Roaming\Typora\typora-user-images\image-20210607103843249.png)
- ![image-20210607103851825](C:\Users\WAW\AppData\Roaming\Typora\typora-user-images\image-20210607103851825.png)
- ![image-20210607103900182](C:\Users\WAW\AppData\Roaming\Typora\typora-user-images\image-20210607103900182.png)
- ![image-20210607103912203](C:\Users\WAW\AppData\Roaming\Typora\typora-user-images\image-20210607103912203.png)
- 面试常见问题i++和++i的区别

### 6.栈顶缓存技术

- 由于基于栈架构的虚拟机所使用的零地址指令更加紧凑，但对应的完成一项操作会有很多的出栈入栈的操作，也就意味着需要频繁的访问内存，影响执行速度，为了解决这个问题，有了栈顶缓存技术，将栈顶元素保存到物理cpu的寄存器中，降低对内存的读写。

### 7.动态链接

- 动态链接或者称为指向运行时常量池的方法的引用，一个类加载到内存中，该类其实包含了很多的结构，为了使生成的字节码文件大小不要那么大，使用了符号引用来解决，即字节码文件不需要存放所用到所有结构，只需要存放所用到结构引用的符号即可，具体结构放在了方法区中，调用方法时只需将符号引用转换为直接引用即可，这一技术也使得多态的特性得以实现
  - ![image-20210607112504884](C:\Users\WAW\AppData\Roaming\Typora\typora-user-images\image-20210607112504884.png)
- 常量池的作用就是为了提供一些符号和常量，便于指令的识别。

### 8.方法的调用

- 在jvm中，方法的调用实质上是指将方法的符号引用转换为直接引用，与此相关的是绑定机制
- 静态链接vs动态链接：静态链接是指被调用的方法在编译期就已确定，且在整个运行期间保持不变，这种情况称为静态链接。动态链接则与之相对，是指调用的方法在编译期无法确定，只能在运行期间将符号引用转换为直接引用。静态链接对应早期绑定，动态链接对应晚期绑定。java这类语言具有多态性的特点，那么自然会有早期绑定和晚期绑定两种方式
- 虚方法vs非虚方法：如果在编译期就确定了具体的调用模板，且在运行期间版本不变，这样的方法为非虚方法（静态方法，私有方法，final方法，实例构造器，父类方法），非虚方法与之相对。对应指令有invokestatic，invokespecial，invokevirtual，invokeinterface（其中invokestatic，invokespecial调用的是非虚方法，其余的（final修饰的除外）称为虚方法）
- 关于invokedynamic指令
- 动态类型语言vs静态类型语言：动态类型语言是判断变量类型是通过变量值本身（如js），静态语言是通过类型信息
- 方法重写的本质：当操作数栈要调用方法时会依次向上查找，若始终没有找到合适的方法会报AbstractMethodError,在java中通过虚方法表找
  - ![image-20210608095311349](C:\Users\WAW\AppData\Roaming\Typora\typora-user-images\image-20210608095311349.png)

### 9.方法返回地址

- 本质上，方法的退出就是当前栈帧出栈的过程，此时需要恢复上层方法的局部变量表，操作数栈，将返回值压入调用者栈帧的操作数栈，设置PC寄存器地址，让调用者继续执行。当方法正常结束时调用者的pc计数器的值作为返回地址，即调用方法指令的下一条指令的地址
- 在执行过程中若发生了异常，且这个异常没有在方法内部处理，而是进行抛出，抛出的异常会存储到异常表中，若异常在异常表中没有找到对应的异常处理器，就会导致方法退出，这种叫做异常完成出口。

### 10.面试问题

- ![image-20210608101323775](C:\Users\WAW\AppData\Roaming\Typora\typora-user-images\image-20210608101323775.png)
  - 关于有没有线程安全问题就看线程直接有没有共享的数据，若有共享的属于看有没有对应的同步机制



## 第六章 本地方法栈

### 1.本地方法接口

- 什么是本地方法：简单讲一个Native Method就是一个Java调用非Java代码的接口。native修饰的关键字，可以跟其他java标识符搭配，除了abstract
- 为什么要使用native method:1.需要与外部环境交互，与操作系统交互
- 现状：java随着版本的迭代，效率有了显著提高，所有本地方法使用的越来越少了

### 2.本地方法栈

- java虚拟机栈用于管理java方法的调用，而本地方法栈用于管理本地方法的调用，本地方法栈也是线程私有的
- 允许被实现成固定大小或可动态扩展大小的内存，关于溢出问题与虚拟机栈的实现机制一致
- 当某个线程调用了一个本地方法时，它就进入了一个全新的并且不再受虚拟机限制的世界，它和虚拟机用于同样的权限，本地方法可以直接方法运行时数据区中的数据，可以直接使用本地处理器中的寄存器，可以直接从本地内存的堆中分配任意数量的内存
- 并不是所有的jvm都支持本地方法区
- ![image-20210615095340276](C:\Users\WAW\AppData\Roaming\Typora\typora-user-images\image-20210615095340276.png)

## 第七章 堆

### 1.堆概述

- 一 个jvm实例只有一个堆内存
- jvm启动时创建堆，创建时大小确定，但后期可以调节，堆在物理上是不连续的，逻辑上是连续的
- 所有的线程共享堆，也可以划分线程私有的缓冲区
- 方法结束后，堆中的对象不会马上被移除，仅仅在垃圾回收的时候才被移除
- 堆是GC执行垃圾回收的重点区域
- ![image-20210615113451202](C:\Users\WAW\AppData\Roaming\Typora\typora-user-images\image-20210615113451202.png)
- 现代垃圾收集器大部分基于分代收集理论设计，7及之前堆内存逻辑上分为：新生区+养老区+永久区，8及之后分为：新生区+养老区+元空间（元空间实际是在方法区）

### 2.设置堆空间大小和OOM

- -Xms用于设置堆区的起始内存，-Xmx用于设置最大内存
- 一旦超出了设置的最大堆内存，会抛出OOM
- 一般将这两个参数设置相同大小，目的是为了能够在java垃圾回收机制清理完堆区后不需要重写分隔计算堆区大小，从而提高性能
- 默认情况下起始内存大小：物理电脑内存大小/64，最大内存大小：物理电脑内存大小/4
- 计算年轻代内存时，两个幸存者区只计算一份

### 3.年轻代和老年代

- java对象有的生命周期短，有点生命周期长，故而针对堆空间的划分按分代划分机制
- 堆区可分年轻代和老年代，其中年轻代又分为Eden空间，幸存者0和幸存者1
- 配置参数：
  - -XX:NewRtio=2:表示新生代1，老年代2
  - -XX:SurvivorRatio=8:表示新生代8，两个幸存者各占1（默认是8，但若开启自适应则是6）
  - -Xmn：设置新生代内存大小（一般使用默认值）
- 几乎所有的java对象都在Eden区诞生（80%），若遇到超大对象，Eden放不下，可直接在老年代诞生
- ![image-20210615125731447](C:\Users\WAW\AppData\Roaming\Typora\typora-user-images\image-20210615125731447.png)

### 4.图解对象分配过程

- ![image-20210615150738248](C:\Users\WAW\AppData\Roaming\Typora\typora-user-images\image-20210615150738248.png)
  - 从幸存者区晋升到老年区一般要15次，但也可以进行参数设置-XX:MaxTenringThreshold=
  - 若Eden区不足时触发Minor GC，若老年区不足时触发Major GC，幸存者区不足不触发GC,若老年区GC后仍不足，OOM
  - 针对幸存者s0,s1:复制之后又交换，谁空谁是to
  - 关于垃圾回收：频繁在新生区收集，很少在老年区收集，几乎不再永久区收集

### 5.Minor GC,Major GC,Full GC

- 按GC回收的区域可分成两类：部分收集（Partial GC），整体收集（Full GC）
  - 部分收集又分为新生代收集和老年代收集和混合收集（收集整个新生代和部分老年代）
  - 整堆收集收集整个堆和方法区
- 年轻代的触发机制：当年轻代空间不足时触发，由于java对象大部分时朝生夕灭的所有年轻代GC触发的比较频繁，且会引发STW
- 老年代触发机制：出现老年代GC一般伴随至少依次的年轻代GC(但不一定)，老年代GC的速度一般比年轻代GC慢10倍以上，STW的时间更长
- Full GC触发机制：

### 6.堆空间分代的思想

- 为什么要分代，不分代不能正常工作吗： 不分代也可以工作，只是分代可以大大提高效率，因为研究表明，大部分对象都是临时对象，如果不分代的话需要频繁的对所有堆空间进行遍历，效率会很低

### 7.内存分配策略

- 优先分配Eden，大对象直接分配到老年代，长期存活的对象分配到老年代
- 动态对象年龄判断：若幸存者区中相同年龄的所有对象大小的综合大于其空间的一般，年龄大于或等于该年龄的对象可以直接进入老年代，无需到达阈值。
- 空间分配担保：

### 8.为对象分配内存：TLAB

- 为什么要有TLAB：堆空间时线程共享的，由于对象实例的创建在jvm中非常频繁，因此在并发环境下从堆区中划分内存空间时线程不安全的，为了避免多个线程操作同一地址，需要使用加锁机制，进而影响分配速度。
- 什么是TLAB，是jvm为每个线程分配的一个私有的缓存区域，使用TLAB可以避免一系列的非线程安全问题，同时提升内存分配的吞吐量，我们将这种内存分配方式称之为快速分配策略
- 再说明：jvm将TLAB作为内存分配的首选，但TLAB所占空间较小只占Eden的1%，但可以通过参数设置，一旦对象在TLAB空间分配内存失败时，jvm会尝试通过使用加锁机制确保数据操作的原子性
- ![image-20210615165705052](C:\Users\WAW\AppData\Roaming\Typora\typora-user-images\image-20210615165705052.png)

### 9.小结空间的参数设置

- 

### 10.堆时分配对象存储的唯一的选择吗

- 一般来说对象是在堆上，但有一种特殊情况，如果经过逃逸分析后发现，一个对象没有逃逸出方法的话，那么就有可能倍优化成栈上分配。此外TaoBaoVM中创新的GCIH技术实现off-heap，将生命周期较长的java对象从heap中移至heap外，并且GC不能管理GCIH内部的java对象，以此达到降低GC的回收频率和提升GC的回收效率的目的
- 逃逸分析：逃逸分析的基本行为就是分析对象的动态作用域，当对象只在方法内部使用则认为没有逃逸，若在外部方法倍应用则认为发生逃逸，没有发生逃逸的对象则可以分配到栈上，随方法执行的结束，栈空间就被移除。
- jdk7之后默认开启了逃逸分析，-XX:+DoEscapeAnalysis显式开启逃逸分析，-XX:+PrintEscapeAnalysis查看逃逸分析的筛选结果
- 结论：开发中能使用局部变量的，就不要使用在方法外定义
- 使用逃逸分析，编译器可以堆代码作如下优化：
  - 栈上分配：若一个对象没有发生逃逸，可以将堆分配转换成栈上分配
  - 同步省略：如果一个对象被发现只能从一个线程被访问到，那么对于这个对象的操作可以不考虑同步。JIT编译器可以借助逃逸分析来判断同步块所使用的锁对象是否只能被一个线程访问而没有被发布到其他线程，如果没有，那么编译这个同步块的时候就会取消对这部分代码的同步，也叫锁消除，大大调高了并发性和性能
  - 分离对象或标量替换：标量是指一个无法再分解成更小的数据的数据，还可以分解的数据叫做聚合量，经过逃逸分析发现一个对象没有发生逃逸，则可以将这个聚合量打散成标量，这个过程叫做标量替换-XX:+EliminateAllocations
- 逃逸分析并不成熟，无法保证逃逸分析的性能消耗一定高于他的消耗

## 第八章 方法区

### 1.栈、堆、方法区的联系

- 从线程共享的角度来看
  - ![image-20210616145847848](C:\Users\WAW\AppData\Roaming\Typora\typora-user-images\image-20210616145847848.png)
- 三者之间关系
  - ![image-20210616145917571](C:\Users\WAW\AppData\Roaming\Typora\typora-user-images\image-20210616145917571.png)

### 2.方法区的理解

- 方法区在哪里：方法区逻辑上是属于堆的一部分，但在物理上是独立于堆的内存空间，可以是不连续的
- 方法区在jvm启动建立，关闭时销毁，大小可固定可扩展，满了一样会OOM，用来保存类的信息
- 7及之前习惯上把方法区称为永久代，但这并不是一个好的idea，由于永久代在虚拟机内存中，所有容易OOM，8之后改为了元空间，是独立于堆的空间即使用本地内存不易报OOM，所以元空间和永久代并不只是名字上的区别

### 3.设置方法区大小和OOM

- 7和7之前跟8不一样，因为用8较多，这里只写8，8使用-XX:MetaspaceSize和-XX:MaxMetaspaceSize指定
- 跟永久代不同，如果不指定大小，虚拟机会耗尽所有的可用系统内存，其默认的初始大小为21M，一旦触及这个线会触发FullGC，为了减少GC建议把初始值设高一些
- 任何解决OOM

### 4.方法区的内部结构

- 方法区中存放了类型信息，常量，静态变量，即时编译器编译后的代码缓存等
- 类型信息（class,interface,enum,annotation）
  - 这个类的完整有效名称
  - 这个类的直接父类的完整有效名称（interface和Object没有父类）
  - 这个类型的修饰符
  - 这个类型直接接口的一个有序列表
- 域信息
  - 所有域相关信息和生命顺序
  - 域信息包括：域名称，域类型，域修饰符
- 方法信息
  - 方法名称
  - 方法返回类型
  - 参数数量和类型
  - 方法修饰符
  - 方法的字节码，操作数栈，局部变量表及大小
  - 异常表
- non-final的类变量vs全局变量：类变量随类加载而加载，没有实例也可以访问，全局变量在编译的时候就会被分配
- 运行时常量池vs常量池
  - 常量池在字节码文件中，运行时常量池在方法区中，加载类时会把常量池中的数据加载到运行时常量池中
  - 常量池表中包括各种字面量和对类型、域、方法的符号引用
- 为什么需要常量池：一个字节码文件一般需要很多的数据支持，通常这种数据很大无法直接放到字节码中，换种方式，可用存放到常量池中，这个字节码包含了指向常量池的引用，在动态链接时用到运行时常量池
- 常量池可以看作时一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等类型

### 5.方法区使用举例

### 6.方法区的演进细节

- 首先明确：只有HotSpot才有永久代
- HotSpot中方法区的变化
  - ![image-20210618101447487](C:\Users\WAW\AppData\Roaming\Typora\typora-user-images\image-20210618101447487.png)
  - ![image-20210618101555979](C:\Users\WAW\AppData\Roaming\Typora\typora-user-images\image-20210618101555979.png)
  - ![image-20210618101605123](C:\Users\WAW\AppData\Roaming\Typora\typora-user-images\image-20210618101605123.png)
  - ![image-20210618101613588](C:\Users\WAW\AppData\Roaming\Typora\typora-user-images\image-20210618101613588.png)
- 为什么永久代要被元空间替换
  - 永久代设置空间大小是很难确定的
  - 对永久代进行调优是很困难的
- StringTable为什么要调整：因为在程序运行中会有大量字符串创建，放在堆里可以更好的对字符串进行回收，若放到方法区中，需触发FullGC才可被回收，效率较低



### 7.方法区的垃圾回收

- 方法区的垃圾回收主要有两部分：常量池中废弃的常量和不再使用的类型，对于回收废弃常量比较简单，只要常量池中的常量没有被任何地方引用就可有被回收。难的是回收不再使用的类型，后面再说。

## 第九章 对象的实例化、内存布局与访问定位

### 1.创建对象的方式

- ![image-20210623173258404](C:\Users\WAW\AppData\Roaming\Typora\typora-user-images\image-20210623173258404.png)

### 2.创建对象的执行步骤

- ![image-20210623175448151](C:\Users\WAW\AppData\Roaming\Typora\typora-user-images\image-20210623175448151.png)

### 3.对象的内存布局

- ![image-20210623191139317](C:\Users\WAW\AppData\Roaming\Typora\typora-user-images\image-20210623191139317.png)
- ![image-20210623191207839](C:\Users\WAW\AppData\Roaming\Typora\typora-user-images\image-20210623191207839.png)

### 4.对象的访问定位

- ![image-20210623192331001](C:\Users\WAW\AppData\Roaming\Typora\typora-user-images\image-20210623192331001.png)
- 直接指针方式：
  - ![image-20210623192416155](C:\Users\WAW\AppData\Roaming\Typora\typora-user-images\image-20210623192416155.png)
- 句柄方式：
  - ![image-20210623192435998](C:\Users\WAW\AppData\Roaming\Typora\typora-user-images\image-20210623192435998.png)
  - 缺点：占用了更多的空间，访问速度稍慢，优点：本地变量表中的引用不需要改变

## 第十章 直接内存

- 不是虚拟机运行时数据区的一部分，直接内存在堆外，直接向系统申请的内存空间
- 来源于NIO，通过存在堆中的DirectByteBuffer操作Native内存
- 通常访问直接内存的速度会优于java堆。即读写性能高
  - 因此出于性能考虑，读写频繁的场合会考虑使用直接内存
- ![image-20210623195755614](C:\Users\WAW\AppData\Roaming\Typora\typora-user-images\image-20210623195755614.png)
- ![image-20210623195808128](C:\Users\WAW\AppData\Roaming\Typora\typora-user-images\image-20210623195808128.png)
- 也会有OOM的情况，也可以设置其大小



## 第十一章 执行引擎

![image-20210624083748155](C:\Users\WAW\AppData\Roaming\Typora\typora-user-images\image-20210624083748155.png)

### 1.执行引擎概述

- 执行引擎是jvm核心组成部分之一
- 虚拟机是一个相对物理机的概念，两种机器都有代码执行能力，区别是物理机的执行引擎是直接俄建立在处理器、缓存、指令集和操作系统层面上的，而虚拟机的执行引擎则则是由软件自行实现的，可以不受物理条件制约，能执行那些不被硬件直接支持的指令集格式
- jvm的主要任务是负责装载字节码到其内部，但字节码文件不能直接运行在操作系统之上，因为字节码指令并非等价于本地机器指令
- 若向让一个程序运行起来，执行引擎的任务是将字节码指令解释/翻译为对应平台上的本地机器指令才行
- 执行引擎 的工作过程
  - ![image-20210624084732843](C:\Users\WAW\AppData\Roaming\Typora\typora-user-images\image-20210624084732843.png)
  - 从外观上看，所有的java虚拟机的执行引擎的输入和输出都是一致的

### 2.java代码编译和执行的过程

- ![image-20210624084923312](C:\Users\WAW\AppData\Roaming\Typora\typora-user-images\image-20210624084923312.png)
- ![image-20210624084934700](C:\Users\WAW\AppData\Roaming\Typora\typora-user-images\image-20210624084934700.png)
- ![image-20210624085006129](C:\Users\WAW\AppData\Roaming\Typora\typora-user-images\image-20210624085006129.png)
- 什么是解释器，什么是jit编译器
  - 解释器堆字节码采用逐行解释的方式执行，即将字节码文件中的内容翻译为对应平台的本地机器指令执行
  - jit编译器就是虚拟机将源代码直接编译成和本地机器平台相关的机器语言
- 为什么说java是班编译班解释型的语言：1.0时代，java只有解释器，后来java又添加了编译器，现在jvm执行java代码时，通常会将解释执行和编译执行两者结合起来进行

### 3.机器码，指令，汇编语言

- ![image-20210624085437167](C:\Users\WAW\AppData\Roaming\Typora\typora-user-images\image-20210624085437167.png)
- 机器码：使用二进制编码的方式表示指令，叫做机器指令码，容易被机器接受，运行快，与cpu紧密相关，不同的种类的cpu对用的机器指令也不同
- 指令vs指令集：指令是在机器码的基础上进行了封装，可读性稍好一些，由于不同的硬件平台，执行同一操作，对应机器码可能不同，所以不同硬件平台的同一种指令，对应机器码也可能不同。指令集是每个平台所支持的指令的集合，称之为对应平台的指令集。
- 在指令的基础上又封装了汇编语言，在汇编语言基础上又封装了高级语言
  - ![image-20210624090110765](C:\Users\WAW\AppData\Roaming\Typora\typora-user-images\image-20210624090110765.png)
- 字节码：
  - ![image-20210624090321182](C:\Users\WAW\AppData\Roaming\Typora\typora-user-images\image-20210624090321182.png)
- c、C++源程序执行过程
  - ![image-20210624090439273](C:\Users\WAW\AppData\Roaming\Typora\typora-user-images\image-20210624090439273.png)

### 4.解释器

- ![image-20210624090628637](C:\Users\WAW\AppData\Roaming\Typora\typora-user-images\image-20210624090628637.png)
- 解释器是一个翻译，将字节码文件逐行翻译成对应的机器指令
- 当执行完一条后，在根据pc寄存器中记录的下一条需要被执行的字节码指令执行解释操作
- 解释器又两套，古老的字节码解释器和现在普遍使用的模板解释器，（了解）
- 现状：由于解释器运行效率较低，常被c/c++程序员调侃，于是出现了即时编译技术，即将整个函数体编译成为机器码，每次函数执行时，只执行编译后的机器码即可

### 5.jit编译器

- Java代码可以通过两种方式运行，即前面提到的编译和解释。
- hotspot采用编译和解释并存的架构，两者可以互补长短，今天java程序的运行性能已可以比肩c.c++
- 为什么需要保留解释器？
  - ![image-20210624091723269](C:\Users\WAW\AppData\Roaming\Typora\typora-user-images\image-20210624091723269.png)
  - ![image-20210624091739427](C:\Users\WAW\AppData\Roaming\Typora\typora-user-images\image-20210624091739427.png)
  - 案例：![image-20210624091755000](C:\Users\WAW\AppData\Roaming\Typora\typora-user-images\image-20210624091755000.png)



## 第十三章 String Table

### 1.String 的基本特性

- ![image-20210626100643979](C:\Users\WAW\AppData\Roaming\Typora\typora-user-images\image-20210626100643979.png)
- 使用byte[]节约空间
- String代表不可变的字符序列，简称：不可变性
  - 当堆字符串重新赋值时，需要重写指定内存区域赋值
  - 当对现有的字符串进行连接操作时，需要重写指定内存区域赋值
  - 当调用String的replace()方法修改指定字符或字符串时，需要重写指定内存区域赋值
- 通过字面量的方式（区别于new）给一个字符串赋值，此时的字符串值声明再字符串常量池中，字符串常量池中不会存储相同的字符串
- ![image-20210626102506313](C:\Users\WAW\AppData\Roaming\Typora\typora-user-images\image-20210626102506313.png)

### 2.String的内存分配

- java中的8种基本数据类型和String类型，这些类型为了使他们再运行过程中的速度更快，更节省内存，都提供了一种常量池的概念
- Sring常量池比较特殊，主要有两种使用方法
  - ![image-20210626102927341](C:\Users\WAW\AppData\Roaming\Typora\typora-user-images\image-20210626102927341.png)
- 6及之前，字符串常量池放到永久代，7放在java堆中，这样作的好处：所有字符串保存再堆中，和其他普通对象一样，这样可以让你再进行调优应用时仅需要调整堆大小就可以。放在堆中方便GC

### 3.String的拼接操作

- 

## 第十四章 垃圾回收概述

### 1.什么是垃圾

- 垃圾收集机制是java的招牌能力，极大的提高了开发效率，如今几乎成为了现代语言的标配，也是面试热点
- 垃圾是指运行程序中没有任何指针指向的对象
- 如果不及时堆内存中的垃圾进行清理，可能会出现OOM的情况
- 为什么需要GC：如果没有GC，内存迟早会被消耗完，没有GC程序无法正常运行。

### 2.早期的垃圾回收

- 在早期的c/c++时代，垃圾是手动管理的。若有一处内存区间由于程序员编码问题忘记回收，那么就会造成内存泄漏
- 现在有了垃圾回收机制后，我们只需要申请空间，不需要手动释放。

### 3.java垃圾回收机制

- 自动内存管理，开发任意无需手动参与内存的分配和回收，降低内存泄漏和内存溢出的风险，使程序员更专心的专注于业务开发。
- 担忧：会弱化程序员应对内存溢出时定位问题和解决问题的能力。
- 为了根据错误异常定位问题和解决问题，需要实施必要的监控和调节
- java堆时垃圾收集器的工作重点，频繁收集Young区，较少收集Old区，基本不动Perm区（或元空间）

## 第十五章 垃圾回收相关算法

### 1.垃圾标记阶段的算法之引用计数算法

- 垃圾标记阶段：对象存活判断
  - 判断那些对象时垃圾，这个阶段称为垃圾标记阶段。
  - 当一个对象不再被任何存活对象继续引用时，就可以宣判为已经死亡
  - 判断对象存活一般有两种方式：引用计算算法和可达性分析算法
- 方式一：引用计数算法
  - 引用计数算法比较简单，对每个对象保存一个整型的引用计数属性，对于对象A，只要有任何一个对象引用了A，那么A的引用计数器就加一。
  - 优点：效率高，简单
  - 缺点：**存在循环引用的问题**
    - ![image-20210626163508082](C:\Users\WAW\AppData\Roaming\Typora\typora-user-images\image-20210626163508082.png)
  - java没有采用，python使用了
  - python如何解决：手动接触，使用弱引用weakref

### 2.垃圾标记阶段的算法之可达性分析（或根搜索算法、追踪性垃圾收集）

- 相对上一种，该方法也简单和高效，且解决了循环引用的问题，防止内存泄漏的发生
- java和c#采用了
- 基本思路：可达性分析算法以根对象集合（GC Roots）为起始点，凡是通过直接或间接的根根对象集合关联都属于活，否则为垃圾，所走路径为引用链
  - ![image-20210628185933784](C:\Users\WAW\AppData\Roaming\Typora\typora-user-images\image-20210628185933784.png)
- GC Roots包括几类元素：
  - 虚拟机栈中引用的对象
  - 本地方法栈中引用的对象
  - 方法区中类静态数学引用的对象
  - 方法区中常量引用的对象
  - 所有被同步锁持有的对象
  - java虚拟机内部的引用
- 小技巧：由于root采用栈方式存放变量和指针，所以如果一个指针，它保存了对内存里面的对象，但自己不放在堆中，它就是一个Root
- 如果要使用可达性分析算法来判断内存是否可回收，那么分析工作需要在快照中进行

### 3.对象的finalization机制

- 这个机制运行一个对象在销毁前进行一些逻辑操作，通常是资源释放，清理的工作
- 注意不要主动调用对象的finalize()方法，应交与垃圾回收机制调用
  - 该方法可能会导致对象复活
  - 该方法的执行时间没有保障，完全由GC线程决定
  - 一个糟糕的finalize()会严重影响GC的性能
- 由于该方法的存在，内存中的对象可以有三种状态
  - 可触及的（活的）
  - 可复活的（该对象的finalize方法中可以复活该对象）
  - 不可触及的：对象的finalize()被调用，并且没有复活，就进入该状态，finalize方法只会被调用一次

### 4.MAT与JProfiler的GC Roots溯源

- MAT是一款功能强大的java堆内存分析器



### 5.垃圾清除阶段算法之标记-清除算法

- jvm中常见的三种垃圾收集算法：标记-清除算法、复制算法、标记-压缩算法
- 标记-清除：一种比较常见和基础的垃圾收集算法
  - ![image-20210628192343244](C:\Users\WAW\AppData\Roaming\Typora\typora-user-images\image-20210628192343244.png)
  - 缺点：
    - 效率不算高
    - 进行GC时需要停止整个应用程序，体验感差
    - 清理出的空闲内存不联系，产生内存碎片，需要维护一个空闲列表

### 6.垃圾清除阶段算法之复制算法

- 核心思想：将活着的内存空间分成两块，每次用一块，每次GC将活着的复制到另一块中
- ![image-20210628192815673](C:\Users\WAW\AppData\Roaming\Typora\typora-user-images\image-20210628192815673.png)
- 优点：简单高效，没有碎片
- 缺点：需要两倍内存空间，
- 特别的：若系统垃圾对象很多，存活对象数量不多，比如Young区中的S1和S0
- 应用场景：在新生代中，一次通常会回收70%-99%的内存空间，所以限制商业虚拟机都是用这种收集算法回收新生代





